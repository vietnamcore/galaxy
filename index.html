<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Orbiting Planet (pure Canvas)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  #hint {
    position:fixed;left:12px;top:12px;color:#ddd;font-family:system-ui,Arial;
    background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;font-size:13px;z-index:10;
  }
</style>
</head>
<body>
<div id="hint">Tap/click to pause â€¢ Resize window if cutoff</div>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 0, H = 0, CX = 0, CY = 0;

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.max(300, window.innerWidth);
    H = Math.max(300, window.innerHeight);
    canvas.width = Math.round(W * DPR);
    canvas.height = Math.round(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
    CX = W / 2; CY = H / 2;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // STARFIELD
  const STAR_COUNT = Math.round(Math.min(1600, (W*H)/9000));
  const stars = [];
  for (let i=0;i<STAR_COUNT;i++){
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: Math.random()*1.4 + 0.2,
      tw: Math.random()*Math.PI*2,
      bright: 0.4 + Math.random()*0.6
    });
  }

  // create a simple planet texture on offscreen canvas
  function makePlanetTexture(d) {
    const s = Math.round(d * DPR);
    const off = document.createElement('canvas');
    off.width = off.height = s;
    const g = off.getContext('2d');
    // radial gradient base
    const rg = g.createRadialGradient(s*0.35, s*0.3, s*0.05, s*0.5, s*0.5, s*0.8);
    rg.addColorStop(0, '#ffdca8');
    rg.addColorStop(0.2, '#ff9a66');
    rg.addColorStop(0.6, '#3366ff');
    rg.addColorStop(1, '#1a2b6b');
    g.fillStyle = rg;
    g.fillRect(0,0,s,s);

    // add soft cloud-ish arcs
    g.globalAlpha = 0.12;
    for (let i=0;i<14;i++){
      g.beginPath();
      const cx = s * (0.25 + Math.random()*0.5);
      const cy = s * (0.2 + Math.random()*0.6);
      const r = s * (0.9 - Math.random()*0.6);
      g.fillStyle = `rgba(255,255,255,${0.04 + Math.random()*0.06})`;
      g.arc(cx, cy, r, Math.random()*Math.PI, Math.random()*Math.PI + Math.PI*0.8);
      g.fill();
    }
    // speckles
    g.globalAlpha = 0.12;
    for (let i=0;i<600; i++){
      g.fillStyle = `rgba(255,255,255,${Math.random()*0.08})`;
      const x = Math.random()*s;
      const y = Math.random()*s;
      g.fillRect(x, y, Math.random()*2, Math.random()*2);
    }
    return off;
  }

  const PLANET_SIZE = Math.min(W,H) * 0.22;
  const planetTex = makePlanetTexture(PLANET_SIZE);

  // orbiters config
  const ORBITERS = [];
  const ORBIT_COUNT = 7;
  for (let i=0;i<ORBIT_COUNT;i++){
    ORBITERS.push({
      radius: PLANET_SIZE*1.6 + i * (PLANET_SIZE*0.28),
      angle: Math.random()*Math.PI*2,
      speed: 0.6 + Math.random()*1.2,
      size: 10 + Math.random()*26,
      hue: Math.round((i*42 + Math.random()*60) % 360)
    });
  }

  let last = performance.now();
  let running = true;
  canvas.addEventListener('click', ()=> running = !running);

  function draw(now) {
    if (!running){
      requestAnimationFrame(draw);
      return;
    }
    const dt = Math.min(0.06, (now - last)/1000);
    last = now;

    // clear
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    // stars (twinkle)
    ctx.save();
    for (let i=0;i<stars.length;i++){
      const s = stars[i];
      s.tw += dt * 1.2;
      const b = s.bright * (0.6 + 0.4*Math.sin(s.tw));
      ctx.fillStyle = `rgba(255,255,255,${0.45*b})`;
      ctx.fillRect(s.x, s.y, s.size, s.size);
    }
    ctx.restore();

    // orbit background subtle glows (additive)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i=0;i<ORBITERS.length;i++){
      const o = ORBITERS[i];
      const r = o.radius;
      // minimal elliptical wobble
      const px = CX + Math.cos(o.angle + now*0.0002*i) * r * (0.94 + 0.06*Math.sin(i+now*0.0006));
      const pz = CY + Math.sin(o.angle*0.98) * r * (0.82 + 0.05*Math.cos(i + now*0.0007));
      const glowRad = o.size * 2.8;
      const g = ctx.createRadialGradient(px, pz, 0, px, pz, glowRad);
      g.addColorStop(0, `hsla(${o.hue},100%,70%,0.55)`);
      g.addColorStop(0.25, `hsla(${o.hue},100%,60%,0.20)`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(px, pz, glowRad, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // planet glow behind
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const pg = ctx.createRadialGradient(CX, CY, 0, CX, CY, PLANET_SIZE*1.8);
    pg.addColorStop(0, 'rgba(120,180,255,0.18)');
    pg.addColorStop(0.5, 'rgba(80,140,255,0.06)');
    pg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = pg;
    ctx.beginPath(); ctx.arc(CX, CY, PLANET_SIZE*1.8, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // draw planet (rotate its texture slowly)
    ctx.save();
    ctx.translate(CX, CY);
    const rot = now * 0.00015;
    ctx.rotate(rot);
    // draw textured circle using clipped draw
    ctx.beginPath(); ctx.arc(0,0, PLANET_SIZE, 0, Math.PI*2); ctx.closePath();
    ctx.clip();
    // draw repeated texture to simulate rotation (draw planetTex centered, but rotate canvas)
    ctx.drawImage(planetTex, -PLANET_SIZE, -PLANET_SIZE, PLANET_SIZE*2, PLANET_SIZE*2);
    ctx.restore();

    // planet rim highlight
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, PLANET_SIZE, 0, Math.PI*2);
    ctx.lineWidth = Math.max(2, PLANET_SIZE*0.03);
    ctx.strokeStyle = 'rgba(255,240,220,0.08)';
    ctx.stroke();
    ctx.restore();

    // orbiters: draw sprites on top
    for (let i=0;i<ORBITERS.length;i++){
      const o = ORBITERS[i];
      o.angle += dt * o.speed * 0.9;
      const px = CX + Math.cos(o.angle) * o.radius;
      const py = CY + Math.sin(o.angle * 0.98) * o.radius * (0.74 + 0.06*Math.sin(i + now*0.001));
      // glow circle
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const rg = ctx.createRadialGradient(px, py, 0, px, py, o.size*3.2);
      rg.addColorStop(0, `hsla(${o.hue}, 100%, 70%, 0.65)`);
      rg.addColorStop(0.25, `hsla(${o.hue}, 100%, 55%, 0.25)`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath(); ctx.arc(px, py, o.size*3.2, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // solid orb
      ctx.save();
      ctx.beginPath();
      ctx.arc(px, py, o.size, 0, Math.PI*2);
      // simple gradient for orb
      const og = ctx.createRadialGradient(px - o.size*0.4, py - o.size*0.4, 0, px, py, o.size);
      og.addColorStop(0, `hsl(${o.hue},100%,85%)`);
      og.addColorStop(0.6, `hsl(${o.hue},80%,45%)`);
      og.addColorStop(1, `rgba(10,10,10,0.6)`);
      ctx.fillStyle = og;
      ctx.fill();
      ctx.restore();

      // small highlight
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath();
      ctx.arc(px - o.size*0.35, py - o.size*0.35, Math.max(1.2, o.size*0.28), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // small foreground sparkles
    for (let i=0;i<6;i++){
      const a = now*0.002 + i*1.1;
      const r = PLANET_SIZE * (0.6 + (i%3)*0.2);
      const sx = CX + Math.cos(a)*r*1.05;
      const sy = CY + Math.sin(a*1.2)*r*0.9;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,240,0.08)';
      ctx.beginPath(); ctx.arc(sx, sy, 2.2, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // end frame
    requestAnimationFrame(draw);
  } // draw

  // start animation
  requestAnimationFrame(draw);

  // debugging helper: if nothing shows, log
  console.log('Canvas orbit demo started. Canvas size:', W, H);
})();
</script>
</body>
</html>
