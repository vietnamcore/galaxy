<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Orbiting Planet — Full HD Effect</title>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #container{width:100%;height:100%;position:fixed;inset:0}
  .ui {
    position: fixed;
    left: 12px;
    top: 12px;
    z-index: 99;
    color: #fff;
    font-family: Inter, system-ui, sans-serif;
    user-select:none;
    background: rgba(0,0,0,0.35);
    padding:10px;
    border-radius:8px;
    backdrop-filter: blur(6px);
  }
  .ui label{font-size:13px;display:block;margin-bottom:6px}
  .ui input[type=range]{width:200px}
  .ui button{margin-top:6px;padding:6px 8px;border-radius:6px;border:none;background:#fff;color:#000;cursor:pointer}
  .credit {position:fixed; right:12px; bottom:12px; color:#aaa; font-size:12px}
</style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" id="ui">
    <label>Speed <span id="speedVal">1.0</span>x</label>
    <input id="speed" type="range" min="0" max="3" step="0.05" value="1">
    <label>Orbit radius scale <span id="radiusVal">1.0</span></label>
    <input id="radius" type="range" min="0.6" max="2.2" step="0.05" value="1">
    <div style="margin-top:8px">
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn" style="margin-left:8px">Reset Camera</button>
    </div>
  </div>

  <div class="credit">Place your images: planet.jpg, orb1.png, orb2.png, orb3.png, orb4.png</div>

<script>
/* ==========================
   CONFIG - chỉnh ở đây nếu muốn
   ========================== */
const CONFIG = {
  ORBIT_COUNT: 6,          // số ảnh/quỹ đạo
  ORBIT_BASE_RADIUS: 3.8,  // bán kính cơ bản (tỉ lệ với world)
  ORBIT_SPREAD: 1.2,       // phân tán các quỹ đạo
  SPEED: 1.0,              // mặc định tốc độ
  PLANET_SIZE: 1.6,        // kích thước hành tinh
  STAR_DENSITY: 1200,      // số sao nền
  IMAGE_NAMES: [           // tên ảnh orbit (thay bằng ảnh bạn có)
    'orb1.png','orb2.png','orb3.png','orb4.png','orb1.png','orb2.png'
  ],
  PLANET_TEXTURE: 'planet.jpg' // đặt image planet.jpg hoặc để null
};

/* ==========================
   Scene setup
   ========================== */
const container = document.getElementById('container');
const scene = new THREE.Scene();

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio ? Math.min(window.devicePixelRatio, 2) : 1);
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
container.appendChild(renderer.domElement);

// camera
const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.set(0, 1.4, 8.5);

// controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.minDistance = 3;
controls.maxDistance = 25;

/* ==========================
   Lights
   ========================== */
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);

const keyLight = new THREE.PointLight(0xfff5ea, 1.1, 0);
keyLight.position.set(5, 5, 5);
scene.add(keyLight);

/* ==========================
   Background starfield (particles)
   ========================== */
function makeStarField(count){
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  for (let i=0; i<count; i++){
    const r = 40 + Math.random()*160;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2*Math.random()-1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
    sizes[i]=Math.random()*1.6+0.4;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes,1));
  const material = new THREE.PointsMaterial({ color:0xffffff, size:0.06, sizeAttenuation:true, opacity:0.9, transparent:true});
  const points = new THREE.Points(geometry, material);
  scene.add(points);
}
makeStarField(CONFIG.STAR_DENSITY);

/* ==========================
   Planet (center)
   ========================== */
const planetGroup = new THREE.Group();
scene.add(planetGroup);

const createPlanet = (textureUrl) => {
  const geo = new THREE.SphereGeometry(CONFIG.PLANET_SIZE, 64, 64);
  if (textureUrl){
    const loader = new THREE.TextureLoader();
    const tex = loader.load(textureUrl, (t)=>{
      t.encoding = THREE.sRGBEncoding;
      renderer.render(scene, camera);
    });
    const mat = new THREE.MeshStandardMaterial({map:tex, roughness:0.6, metalness:0.05});
    const mesh = new THREE.Mesh(geo, mat);
    return mesh;
  } else {
    // fallback gradient shader-like material
    const mat = new THREE.MeshStandardMaterial({color:0x3366ff, roughness:0.8, metalness:0.1});
    return new THREE.Mesh(geo, mat);
  }
};

let planetMesh;
if (CONFIG.PLANET_TEXTURE){
  planetMesh = createPlanet(CONFIG.PLANET_TEXTURE);
} else {
  planetMesh = createPlanet(null);
}
planetGroup.add(planetMesh);

/* subtle atmosphere glow */
const atmosphereGeom = new THREE.SphereGeometry(CONFIG.PLANET_SIZE*1.06, 32, 32);
const atmosphereMat = new THREE.MeshBasicMaterial({color:0x88ccff, transparent:true, opacity:0.06, blending:THREE.AdditiveBlending});
const atmosphere = new THREE.Mesh(atmosphereGeom, atmosphereMat);
planetGroup.add(atmosphere);


/* ==========================
   Orbiting image sprites
   ========================== */
const spriteLoader = new THREE.TextureLoader();
const orbitObjects = [];

function addOrb(index, textureName, radius, speedFactor, tilt){
  // sprite
  const tex = spriteLoader.load(textureName);
  tex.encoding = THREE.sRGBEncoding;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  const spr = new THREE.Sprite(mat);
  // scale based on texture / desired view
  const scale = 0.9 + Math.random()*0.9; // change as needed
  spr.scale.set(scale, scale, 1);
  const obj = {
    mesh: spr,
    baseRadius: radius,
    speed: (0.4 + Math.random()*0.8) * speedFactor,
    angle: Math.random() * Math.PI * 2,
    tilt: tilt
  };
  orbitObjects.push(obj);
  scene.add(spr);
}

// create N orbiters from CONFIG. Use given texture names cycling
const N = CONFIG.ORBIT_COUNT;
for (let i=0;i<N;i++){
  const name = CONFIG.IMAGE_NAMES[i % CONFIG.IMAGE_NAMES.length];
  const baseR = CONFIG.ORBIT_BASE_RADIUS + (i%3) * CONFIG.ORBIT_SPREAD*0.9 + (Math.floor(i/3)*0.6);
  const sp = 0.9 + (i%4)*0.12;
  const tilt = (Math.random()-0.5)*0.6;
  addOrb(i, name, baseR, 1.0 + Math.random()*0.6, tilt);
}

/* ==========================
   Post-processing bloom (subtle)
   ========================== */
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.7, 0.9, 0.8);
bloomPass.threshold = 0.1;
bloomPass.strength = 0.9;
bloomPass.radius = 0.8;
composer.addPass(bloomPass);

/* ==========================
   Animation loop
   ========================== */
let last = performance.now();
let globalSpeed = CONFIG.SPEED;
function animate(now){
  const dt = (now - last) / 1000; last = now;
  // rotate planet slowly
  planetMesh.rotation.y += 0.12 * dt * globalSpeed;
  atmosphere.rotation.y += 0.05 * dt * globalSpeed;

  // animate orbiters
  for (let i=0;i<orbitObjects.length;i++){
    const o = orbitObjects[i];
    o.angle += dt * o.speed * 0.6 * globalSpeed;
    // compute position on a tilted elliptical orbit
    const x = Math.cos(o.angle) * o.baseRadius;
    const z = Math.sin(o.angle) * o.baseRadius * (0.8 + 0.15*Math.sin(i + now*0.0005));
    const y = Math.sin(o.angle * 0.8 + i) * 0.3 * o.tilt;
    o.mesh.position.set(x, y, z);
    // face camera
    o.mesh.lookAt(camera.position);
    // subtle bob scale
    const s = 0.9 + 0.08 * Math.sin(now * 0.004 + i);
    o.mesh.scale.set(s, s, 1);
  }

  controls.update();
  composer.render(dt);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ==========================
   UI interactions
   ========================== */
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const radiusRange = document.getElementById('radius');
const radiusVal = document.getElementById('radiusVal');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

speedRange.addEventListener('input', (e)=>{
  globalSpeed = parseFloat(e.target.value);
  speedVal.textContent = globalSpeed.toFixed(2);
});
radiusRange.addEventListener('input', (e)=>{
  const scale = parseFloat(e.target.value);
  radiusVal.textContent = scale.toFixed(2);
  for (let i=0;i<orbitObjects.length;i++){
    orbitObjects[i].baseRadius = (CONFIG.ORBIT_BASE_RADIUS + (i%3) * CONFIG.ORBIT_SPREAD*0.9 + Math.floor(i/3)*0.6) * scale;
  }
});

let paused = false;
pauseBtn.addEventListener('click', ()=>{
  paused = !paused;
  if (paused){
    pauseBtn.textContent = 'Resume';
    renderer.setAnimationLoop(null);
  } else {
    pauseBtn.textContent = 'Pause';
    last = performance.now();
    requestAnimationFrame(animate);
  }
});

resetBtn.addEventListener('click', ()=>{
  camera.position.set(0, 1.4, 8.5);
  controls.target.set(0,0,0);
  controls.update();
});

/* ==========================
   Resize handling
   ========================== */
window.addEventListener('resize', onWindowResize);
function onWindowResize(){
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
}
</script>
</body>
</html>
